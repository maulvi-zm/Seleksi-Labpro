## B08 - SOLID Principles

The SOLID principles are a set of design guidelines that promote maintainability, flexibility, and scalability in object-oriented programming (OOP). In this project, the backend of the monolithic service and REST API has been implemented using NestJS and Prisma, both of which naturally align with SOLID principles. Additionally, I have used the Builder pattern and Strategy pattern to further adhere to these principles.

#### 1. **Single Responsibility Principle (SRP)**

- **NestJS**: In NestJS, the modular architecture encourages separating concerns into different modules, services, and controllers, each having a single responsibility. For example, a service is solely responsible for the business logic, while a controller handles HTTP requests.
- **Prisma**: With Prisma, data access logic is separated from the business logic, ensuring that each class or module has only one reason to change.
- **RecommendationQueryBuilder**: The `RecommendationQueryBuilder` class is responsible only for constructing complex queries to fetch recommended films. It adheres to SRP by encapsulating the logic needed to build a query without interacting with other parts of the system.

#### 2. **Open/Closed Principle (OCP)**

- **NestJS**: The use of decorators and middleware in NestJS allows for extending functionality without modifying existing code. This ensures that the system can be extended with new features or behaviors without altering the existing, tested codebase.
- **Prisma**: Prisma models can be extended with new fields or relations without affecting the existing schema or query logic.
- **Storage Strategy Pattern**: The `StorageStrategy` interface exemplifies OCP by allowing the addition of new storage strategies (e.g., AWS S3, Cloudflare R2) without altering the existing codebase. Implementations of the `StorageStrategy` interface can be swapped or added as needed.

#### 3. **Liskov Substitution Principle (LSP)**

- **NestJS**: The modular and injectable nature of services in NestJS allows any service to be substituted with another, provided it adheres to the expected interface or contract. This makes it easy to replace or mock services during testing.
- **Storage Strategy Pattern**: Any class implementing the `StorageStrategy` interface can be used interchangeably, ensuring that the `uploadFile` and `deleteFile` methods can be called without modification to the code that uses them.

#### 4. **Interface Segregation Principle (ISP)**

- **Storage Strategy Pattern**: The `StorageStrategy` interface is an example of ISP, as it defines a contract with only the methods that are necessary for file storage operations (`uploadFile` and `deleteFile`). This ensures that classes implementing this interface are not forced to implement methods they do not use.

#### 5. **Dependency Inversion Principle (DIP)**

- **NestJS**: NestJSâ€™s dependency injection system allows higher-level modules to depend on abstractions (e.g., interfaces) rather than concrete implementations. This decouples the system and promotes flexibility and testability.
- **Prisma**: Prisma clients are injected where needed, rather than being directly instantiated, adhering to DIP by ensuring that dependencies are managed and injected externally.
- **RecommendationQueryBuilder**: The builder pattern used in `RecommendationQueryBuilder` allows the construction logic to be decoupled from the actual use of the query object, making the code more flexible and easier to maintain.

### Conclusion

By leveraging NestJS, Prisma, the Builder pattern, and the Strategy pattern, the project adheres to the SOLID principles, ensuring that the codebase is modular, maintainable, and scalable. This results in a more robust and flexible system, capable of adapting to changing requirements with minimal refactoring.
